## Overview

| Developed by | Guardrails AI |
| --- | --- |
| Date of development | Feb 15th, 2024 |
| Validator type | Safety |
| Blog | - |
| License | Apache 2 |
| Input/Output | Input, Output |

## Description

This validator monitors any text (input or output) and detects secrets present in the text. Under-the-hood, the validator uses the `detect-secrets` library to check whether the text contains any secrets. If any secrets are detected, the validator fails and returns the text with the secrets replaced with asterisks. Otherwise, the validator returns the generated code snippet.

### Resources required

- Dependencies: `detect-secrets`

## Installation

```bash
$ gudardrails hub install hub://guardrails/detect_secrets
```

## Usage Examples

### Validating string output via Python

In this example, we apply the validator to a string output generated by an LLM.

```python
# Import Guard and Validator
from guardrails.hub import DetectSecrets
from guardrails import Guard

val = DetectSecrets(
    on_fail="fix"
)

guard = Guard.from_string(validators=[val])

guard.parse("Some message without secrets")  # Validator passes
guard.parse("Some message with sk-******")  # Validator fails
```

### Validating JSON output via Python

In this example, we apply the validator to a string field of a JSON output generated by an LLM.

```python
# Import Guard and Validator
from pydantic import BaseModel
from guardrails.hub import DetectSecrets
from guardrails import Guard

val = DetectSecrets(
    on_fail="fix"
)

# Create Pydantic BaseModel
class UserMsg(BaseModel):
    timestamp: int
    content: str = Field(
        description="Msg by user", validators=[val]
    )

# Create a Guard to check for valid Pydantic output
guard = Guard.from_pydantic(output_class=UserMsg)

# Run LLM output generating JSON through guard
guard.parse("""
{
    "timestamp": 1707718924,
    "content": "Hi, can you help me with my account?"
}
""")
```

## API Reference

**`__init__(self, on_fail="noop")`**
<ul>

Initializes a new instance of the Validator class.

**Parameters:**

- **`on_fail`** *(str, Callable):* The policy to enact when a validator fails. If `str`, must be one of `reask`, `fix`, `filter`, `refrain`, `noop`, `exception` or `fix_reask`. Otherwise, must be a function that is called when the validator fails.

</ul>

<br>

**`__call__(self, value, metadata={}) â†’ ValidationOutcome`**

<ul>

Validates the given `value` using the rules defined in this validator, relying on the `metadata` provided to customize the validation process. This method is automatically invoked by `guard.parse(...)`, ensuring the validation logic is applied to the input data.

Note:

1. This method should not be called directly by the user. Instead, invoke `guard.parse(...)` where this method will be called internally for each associated Validator.
2. When invoking `guard.parse(...)`, ensure to pass the appropriate `metadata` dictionary that includes keys and values required by this validator. If `guard` is associated with multiple validators, combine all necessary metadata into a single dictionary.

**Parameters:**

- **`value`** *(Any):* The input value to validate.
- **`metadata`** *(dict):* A dictionary containing metadata required for validation. No additional metadata keys are needed for this validator.

</ul>
  
